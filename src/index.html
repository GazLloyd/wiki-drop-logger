<!DOCTYPE html>
<html>
	<head>
		<style>
			body {
				display: none;
			}
		</style>
		<meta http-equiv="Permissions-Policy" content="interest-cohort=(), user-id=()" />
		<script src='https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js'></script>
		<script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js "></script>
		<script>
			// byte array to hex string: https://www.xaymar.com/articles/2020/12/08/fastest-uint8array-to-hex-string-conversion-in-javascript/
			// Pre-Init
			const LUT_HEX_4b = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'];
			const LUT_HEX_8b = new Array(0x100);
			for (let n = 0; n < 0x100; n++) {
			  LUT_HEX_8b[n] = `${LUT_HEX_4b[(n >>> 4) & 0xF]}${LUT_HEX_4b[n & 0xF]}`;
			}
			// End Pre-Init
			function _toHex(buffer, length) {
			  let out = '';
			  for (let idx = 0, edx = length; idx < edx; idx++) {
				out += LUT_HEX_8b[buffer[idx]];
			  }
			  return out;
			}
			function toHex(buffer) { // for regular style arrays like ImageData.data
				return _toHex(buffer, buffer.length)
			}
			function arrayBufferToHex(buffer) { //for array buffers like Blob.arrayBuffer()
				let view = new Uint8Array(buffer);
				return _toHex(view, view.byteLength)
			}

			function hasFoundMobName() {
				return document.getElementById('Mob').getAttribute('data-found') === 'true';
			}

			/* This function courtesy of ChatGPT */
			async function parseText(text) {
				if (text === undefined || text === '') {
					return
				}

				let regex = /\,/g;
				// Split the text into lines
				const lines = text.replace(regex, '').split('\n');
				// Remove the header line
				lines.shift();

				// Initialize an array to store the objects
				const items = [];

				// Iterate over each line
				lines.forEach(line => {
					// Split each line into words
					const words = line.split(' ');

					// Extract the name (joining multiple words if necessary)
					const name = words.slice(0, -1).join(' ');

					// Extract the quantity
					const quantity = parseInt(words[words.length - 1], 10);

					// Construct the object and push it to the array
					if (name === '' || quantity === null || isNaN(quantity)) {
						return
					}
					items.push({ 'name': name, 'quantity': quantity });
				});

				return items;
			}

			/* This function courtesy of ChatGPT */
			/* frick AI */
			async function generateTable(data) {
				if (data === undefined) {
					return;
				}
				let html = '<table>\n';
				html += '<tr><th>Drop</th><th>Quantity</th></tr>\n';

				data.forEach(item => {
					if (item.name === '' || isNaN(item.quantity) || item.quantity == null) {
						return;
					}
					html += `<tr><td>${item.name}</td><td>${item.quantity}</td></tr>\n`;
				});

				html += '</table>';
				return html;
			}

			/* Wouldn't you have guessed it? Courtesy of ChatGPT */
			async function updateQuantity(totalLootData, parsed) {
				if (totalLootData === undefined || parsed === undefined) {
					return;
				}
				if (totalLootData.length === 0 || parsed.length === 0) {
					return;
				}
				const diffs = [];


				// Create a map of names to quantities for quick lookup
				const quantityMap = {};
				parsed.forEach(item => {
					quantityMap[item.name] = item.quantity;
				});

				// Update quantities in dataArray if corresponding name exists in dataArray2
				let updatedQuantity = false;
				totalLootData.forEach(item => {
					if (quantityMap.hasOwnProperty(item.name)) {
						if (item.quantity !== quantityMap[item.name]) {
							updatedQuantity = true;
							diffs.push({ name: item.name, quantity: quantityMap[item.name]-item.quantity })
						}
						item.quantity = quantityMap[item.name];
						delete quantityMap[item.name]; // Remove updated items from quantityMap
					}
				});

				// Append new objects from dataArray2 to dataArray
				let addedItem = false;
				parsed.forEach(item => {
					if (!totalLootData.find(element => element.name === item.name)) {
						totalLootData.push(item);
						addedItem = true;
					}
				});

				// New drops update quantity as well - so this counts new and updated drops
				if (updatedQuantity || addedItem) {
					console.log('Drop update detected! Adding to kc');
					kc++;
				}

				document.querySelectorAll('#KillCount')[0].innerHTML = kc.toString();
				return [totalLootData, diffs];
			}

			function RGBToGrayScale(red,green,blue){
				return (red * 6966 + green * 23436 + blue * 2366) >> 15;
			}

			function threshold(grayscale){
			const thresholdValue = 200;
				if (grayscale < thresholdValue) {
					return true;
				}else{
					return false;
				}
			}

			let reverseColors = ({data}) => {
				for (i = 0; i < data.length; i += 4) {
					data[i] = 255 - data[i];
					data[i + 1] = 255 - data[i + 1];
					data[i + 2] = 255 - data[i + 2];
					data[i + 3] = 255;
				}
				for (var i = 0; i < data.length; i += 4) {
				const red = data[i];
				const green = data[i + 1];
				const blue = data[i + 2];
				const grayscale = RGBToGrayScale(red, green, blue)
				if (threshold(grayscale)) {
					data[i] = 0;
					data[i + 1] = 0;
					data[i + 2] = 0;
				}else{
					data[i] = 255;
					data[i + 1] = 255;
					data[i + 2] = 255;
				}
				}
				return data
			}

			async function canvasToBlob(canvas) {
				return new Promise(resolve=>canvas.toBlob(resolve));
			}

			var worker;
			var totalLootData;
			var lastCanvasData;
			var pendingLootDiffs = [];
			var prevLootImg = null;
			var prevCanvasData = null;
			var currCanvasData = null;
			var kc = 0;
			async function readImage(canvas, ctx) {
				if (worker === undefined) {
					worker = await Tesseract.createWorker('eng');
					console.log('Worker created');
				}
				var input_image = document.getElementById('LootImage');
				ctx.drawImage(input_image, 0, 0);
				const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height)
				imgData.data = reverseColors(imgData)
				ctx.putImageData(imgData, 0, 0)
				let canvasData = canvas.toDataURL();
				input_image.setAttribute('src', canvasData)

				if (input_image.getAttribute('src').length > 0) {
					if (lastCanvasData !== undefined) {
						if (canvasData.slice(0,-100) == lastCanvasData.slice(0,-100)) {
							console.log('Drops image is same as last check - skipping OCR step');
							setTimeout(() => {
								readImage(canvas, ctx);
							}, 50)
							return;
						}
					}
					var lootDiff;
					const { data: { text } } = await worker.recognize(canvasData);
					if (text !== undefined) {
						const parsed = await parseText(text);
						if (totalLootData === undefined) {
							totalLootData = parsed;
							lootDiff = [];
						} else {
							[totalLootData, lootDiff] = await updateQuantity(totalLootData, parsed);
						}
						const tableHTML = await generateTable(totalLootData);
						if (lootDiff.length>0) {
							prevCanvasData = currCanvasData;
							currCanvasData = await canvasToBlob(canvas);
							document.getElementById('LootOutput').innerHTML = tableHTML;
							console.log(lootDiff);
							sendToAPI(lootDiff, kc).then(console.log); // not awaiting, we don't want to wait for it here
							//pendingLootDiffs.push(lootDiff);
						}
					}
					lastCanvasData = canvasData;
					setTimeout(() => {
						readImage(canvas, ctx);
					}, 150)
				};
			}

			async function sendToAPI(diffs, kcid) {
				console.log('sendToAPI', diffs, kcid);
				if (diffs.length===0) return;
				if (!hasFoundMobName()) return;
				let mobname = document.getElementById('Mob').innerText;
				let username = document.getElementById('username').value;
				if (typeof(username) === 'string') {
					username = username.trim();
				}
				if (username === null || username === undefined || username === '' || username === 'null' || username === 'undefined') {
					return;
				}
				let data = {
					monsterName: mobname,
					username: username,
					loot: diffs,
					mapPng: arrayBufferToHex(await window.current_map_data.toFileBytes()),
					beforePng: arrayBufferToHex(await prevCanvasData.arrayBuffer()),
					afterPng: arrayBufferToHex(await currCanvasData.arrayBuffer())
				}
				let tr = document.createElement('tr');
				tr.setAttribute('id', 'RecentOutputRow-'+kcid.toString());
				let td = document.createElement('td');
				td.innerText = kcid.toString();
				tr.appendChild(td);

				td = document.createElement('td');
				td.innerText = JSON.stringify(diffs);
				tr.appendChild(td);

				let successTd = document.createElement('td')
				tr.appendChild(successTd);
				document.getElementById('RecentLootHeader').after(tr);
				console.log(`sending request for username: ${data.username} - mob: ${data.monsterName} - lootdiff: ${JSON.stringify(data.loot)} - map bytes length: ${data.mapPng.length} - before bytes length: ${data.beforePng.length} - after bytes length: ${data.afterPng.length}`)
				let r = await fetch('https://chisel.weirdgloop.org/droplogs-alt1/submit', {method:'POST', body: JSON.stringify(data)});
				let jsr = await r.json();
				console.log(r.status, jsr);
				if (jsr.success) {
					successTd.innerText = "✔️";
				} else {
					successTd.innerText = "❌";
					successTd.setAttribute('title', jsr.error+'\n'+jsr.details);
				}
			}

			document.addEventListener('DOMContentLoaded', function(){
				setTimeout(() => {
					const canvas = document.querySelector('#Canvas');
					const ctx = canvas.getContext('2d', { willReadFrequently: true });
					ctx.scale(2.25, 2.25);
					readImage(canvas, ctx);
				}, 3000);
				document.getElementById('username').value = window.localStorage.getItem('username')
				document.getElementById('username').addEventListener('input', function(){
					window.localStorage.setItem('username', document.getElementById('username').value);
				});
			});

		</script>
	</head>
	<body id="app">
		<div id="output"></div>
		<div id="DropLog">
			<div id="Map">
				<h2>Map</h2>
			</div>
			<div id="MobKC">
				<div id="Mob" data-found="false">(not yet detected)</div>
				<div id="KillCount">0</div>
			</div>
			<div id="RecentLoot" class="loottable">
				<h2>Recent Loot</h2>
				<table id="RecentLootOutput">
					<tr id="RecentLootHeader">
						<th>#</th>
						<th>Loot</th>
						<th title="Submission status">Sub</th>
					</tr>
				</table>
			</div>
			<div id="Loot">
				<h2>All Loot</h2>
				<div id="LootOutput" class="loottable"></div>
				<img id="LootImage" src="" style="display:none;">
			</div>
			<canvas id="Canvas" width="2000" height="2000" style="display:none;"></canvas>
		</div>
		<div id="Settings">
			<div class="container">
				<div class="info">
					The username entered below is not publicly visible.
				</div>
				<div class="setting">
					<label for="username">Username:</label><input type="text" id="username" name="username"/>
				</div>
			</div>
		</div>
		<script src="./main.js" defer></script>
	</body>
</html>
